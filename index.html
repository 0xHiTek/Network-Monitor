// ============================================
// NETWORK MONITOR BACKEND SERVER
// ============================================
// Save this file as: server.js

const express = require('express');
const cors = require('cors');
const { exec } = require('child_process');
const util = require('util');
const execPromise = util.promisify(exec);
const os = require('os');
const ping = require('ping');
const arp = require('node-arp');
const WebSocket = require('ws');
const path = require('path');

const app = express();
const PORT = 3000;

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.static('public')); // Serve the HTML file from public folder

// Store discovered devices
let devices = new Map();
let scanInProgress = false;

// ============================================
// NETWORK SCANNING FUNCTIONS
// ============================================

// Get all network interfaces information
function getAllNetworks() {
    const interfaces = os.networkInterfaces();
    const networks = [];
    
    for (const name of Object.keys(interfaces)) {
        for (const iface of interfaces[name]) {
            if (iface.family === 'IPv4' && !iface.internal) {
                const ip = iface.address;
                const netmask = iface.netmask;
                const networkRange = calculateNetworkRange(ip, netmask);
                networks.push({
                    interface: name,
                    ip,
                    netmask,
                    networkRange
                });
            }
        }
    }
    
    return networks;
}

// Get primary network (for backward compatibility)
function getLocalNetwork() {
    const networks = getAllNetworks();
    return networks.length > 0 ? networks[0] : null;
}

// Get prioritized network ranges to scan (smart detection)
function getPrioritizedNetworkRanges() {
    const localNetworks = getAllNetworks();
    const ranges = [];
    
    // Add directly connected networks (highest priority)
    localNetworks.forEach(network => {
        ranges.push({ range: network.networkRange, priority: 1, type: 'local' });
    });
    
    // Add adjacent VLAN ranges based on current network
    localNetworks.forEach(network => {
        const parts = network.ip.split('.');
        const baseNetwork = `${parts[0]}.${parts[1]}`;
        const currentSubnet = parseInt(parts[2]);
        
        // Scan adjacent subnets (Â±5 range for performance)
        for (let i = Math.max(0, currentSubnet - 5); i <= Math.min(255, currentSubnet + 5); i++) {
            if (i !== currentSubnet) {
                ranges.push({ 
                    range: `${baseNetwork}.${i}.0/24`, 
                    priority: 2, 
                    type: 'adjacent' 
                });
            }
        }
    });
    
    // Add common network ranges (lower priority)
    const commonRanges = [
        '192.168.1.0/24',   // Most common home/small office
        '192.168.0.0/24',   // Common home router default
        '10.0.0.0/24',      // Common enterprise
        '10.0.1.0/24',      // Common enterprise
        '172.16.1.0/24',    // Enterprise private range
    ];
    
    commonRanges.forEach(range => {
        // Only add if not already in our list
        if (!ranges.find(r => r.range === range)) {
            ranges.push({ range, priority: 3, type: 'common' });
        }
    });
    
    // Sort by priority and return only the ranges
    return ranges.sort((a, b) => a.priority - b.priority).map(r => r.range);
}

// Calculate network range (simplified for /24 networks)
function calculateNetworkRange(ip, netmask) {
    // For simplicity, assuming /24 network
    const ipParts = ip.split('.');
    return `${ipParts[0]}.${ipParts[1]}.${ipParts[2]}.0/24`;
}

// Scan multiple networks (multi-VLAN support)
async function scanMultipleNetworks() {
    const discoveredDevices = [];
    
    // Get directly connected networks
    const localNetworks = getAllNetworks();
    
    // Get prioritized network ranges (smart scanning)
    const prioritizedRanges = getPrioritizedNetworkRanges();
    const networksToScan = new Set(prioritizedRanges.slice(0, 10)); // Limit to top 10 ranges for performance
    
    console.log(`Scanning ${networksToScan.size} network ranges...`);
    
    // Scan each network range
    for (const networkRange of networksToScan) {
        console.log(`Scanning network: ${networkRange}`);
        const devices = await scanNetworkRange(networkRange);
        discoveredDevices.push(...devices);
    }
    
    console.log(`Multi-network scan complete. Found ${discoveredDevices.length} devices total.`);
    return discoveredDevices;
}

// Scan network using ARP (works on local network only) - legacy function
async function scanNetworkARP() {
    return await scanMultipleNetworks();
}

// Pre-check if network range is reachable (gateway ping)
async function isNetworkRangeReachable(networkRange) {
    const baseIP = networkRange.split('/')[0].split('.').slice(0, 3).join('.');
    const gatewayIP = `${baseIP}.1`;
    
    try {
        const result = await ping.promise.probe(gatewayIP, { 
            timeout: 2, 
            min_reply: 1,
            extra: process.platform === 'win32' ? ['-n', '1'] : ['-c', '1']
        });
        return result.alive;
    } catch {
        return false;
    }
}

// Scan a specific network range
async function scanNetworkRange(networkRange) {
    // First check if network range is reachable
    console.log(`Pre-checking network reachability: ${networkRange}`);
    const isReachable = await isNetworkRangeReachable(networkRange);
    
    if (!isReachable) {
        console.log(`Network ${networkRange} appears unreachable, skipping...`);
        return [];
    }
    
    console.log(`Network ${networkRange} is reachable, scanning hosts...`);
    
    const baseIP = networkRange.split('/')[0].split('.').slice(0, 3).join('.');
    const discoveredDevices = [];

    // Scan IP range (1-254) with limited concurrency for better performance
    const scanPromises = [];
    const batchSize = 15; // Further reduced batch size for better performance
    
    for (let i = 1; i <= 254; i += batchSize) {
        const batchPromises = [];
        const endIndex = Math.min(i + batchSize - 1, 254);
        
        for (let j = i; j <= endIndex; j++) {
            const ip = `${baseIP}.${j}`;
            batchPromises.push(scanHost(ip));
        }
        
        // Process batch
        const batchResults = await Promise.allSettled(batchPromises);
        const foundInBatch = [];
        batchResults.forEach(result => {
            if (result.status === 'fulfilled' && result.value) {
                discoveredDevices.push(result.value);
                foundInBatch.push(result.value.ip);
            }
        });
        
        if (foundInBatch.length > 0) {
            console.log(`Found ${foundInBatch.length} devices in batch: ${foundInBatch.join(', ')}`);
        }
        
        // Small delay between batches to be network-friendly and prevent timeouts
        if (endIndex < 254) {
            await new Promise(resolve => setTimeout(resolve, 200));
        }
    }
    
    console.log(`Completed scanning ${networkRange}: found ${discoveredDevices.length} devices`);
    return discoveredDevices;
}

// Scan individual host
async function scanHost(ip) {
    try {
        // Configure ping for Windows
        const isAlive = await ping.promise.probe(ip, {
            timeout: 2,          // Windows needs slightly more time
            min_reply: 1,
            extra: process.platform === 'win32' ? ['-n', '1'] : ['-c', '1']  // Windows vs Linux syntax
        });

        if (isAlive.alive) {
            // Get MAC address using ARP
            const macAddress = await getMacAddress(ip);
            
            // Get hostname
            const hostname = await getHostname(ip);
            
            // Determine device type (basic heuristic)
            const deviceType = guessDeviceType(ip, hostname, macAddress);
            
            return {
                ip,
                mac: macAddress || 'Unknown',
                hostname: hostname || ip,
                type: deviceType,
                status: 'online',
                lastSeen: new Date(),
                responseTime: isAlive.time || 0
            };
        }
    } catch (error) {
        // Host not reachable
    }
    return null;
}

// Get MAC address for an IP
function getMacAddress(ip) {
    return new Promise((resolve) => {
        arp.getMAC(ip, (err, mac) => {
            resolve(err ? null : mac);
        });
    });
}

// Get hostname for an IP
async function getHostname(ip) {
    try {
        const { stdout } = await execPromise(`nslookup ${ip}`);
        const match = stdout.match(/name = (.+)/i);
        return match ? match[1].trim() : null;
    } catch {
        return null;
    }
}

// Guess device type based on various factors
function guessDeviceType(ip, hostname, mac) {
    const ipParts = ip.split('.');
    const lastOctet = parseInt(ipParts[3]);
    
    // Router usually at .1
    if (lastOctet === 1) return 'Router';
    
    // Check hostname patterns
    if (hostname) {
        const lower = hostname.toLowerCase();
        if (lower.includes('router') || lower.includes('gateway')) return 'Router';
        if (lower.includes('switch')) return 'Switch';
        if (lower.includes('printer')) return 'Printer';
        if (lower.includes('phone') || lower.includes('android') || lower.includes('iphone')) return 'Phone';
        if (lower.includes('tv') || lower.includes('roku') || lower.includes('chromecast')) return 'Smart TV';
        if (lower.includes('camera')) return 'Camera';
        if (lower.includes('server')) return 'Server';
    }
    
    // Check MAC vendor (simplified)
    if (mac) {
        const vendor = mac.substring(0, 8).toUpperCase();
        // Add vendor checks here based on OUI database
    }
    
    // Default based on IP range
    if (lastOctet <= 50) return 'Server';
    if (lastOctet <= 100) return 'Computer';
    return 'Device';
}

// Monitor device performance (simulated for now)
async function getDeviceMetrics(ip) {
    // In production, you would use SNMP or WMI for real metrics
    return {
        cpu: Math.floor(Math.random() * 100),
        memory: Math.floor(Math.random() * 100),
        bandwidth: Math.floor(Math.random() * 1000),
        uptime: Math.floor(Math.random() * 86400)
    };
}

// ============================================
// API ROUTES
// ============================================

// Get network information (single network - legacy)
app.get('/api/network-info', (req, res) => {
    const network = getLocalNetwork();
    res.json(network);
});

// Get all network interfaces information
app.get('/api/networks', (req, res) => {
    const networks = getAllNetworks();
    const commonRanges = getPrioritizedNetworkRanges();
    res.json({
        localNetworks: networks,
        prioritizedRanges: commonRanges,
        totalRanges: Math.min(commonRanges.length, 10)  // Limited for performance
    });
});

// Scan network
app.post('/api/scan', async (req, res) => {
    if (scanInProgress) {
        return res.status(409).json({ error: 'Scan already in progress' });
    }

    scanInProgress = true;
    console.log('Starting network scan with timeout protection...');
    
    try {
        // Add timeout protection (max 5 minutes)
        const scanPromise = scanNetworkARP();
        const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error('Scan timeout after 5 minutes')), 300000);
        });
        
        const discoveredDevices = await Promise.race([scanPromise, timeoutPromise]);
        
        // Update devices map
        discoveredDevices.forEach(device => {
            devices.set(device.ip, device);
        });
        
        // Broadcast update to WebSocket clients
        const allDevices = Array.from(devices.values());
        console.log(`Scan complete. Total devices in map: ${allDevices.length}`);
        broadcastUpdate('scan-complete', allDevices);
        
        res.json({
            success: true,
            devicesFound: discoveredDevices.length,
            totalDevices: allDevices.length,
            devices: allDevices
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    } finally {
        scanInProgress = false;
    }
});

// Get all devices
app.get('/api/devices', (req, res) => {
    res.json(Array.from(devices.values()));
});

// Get device details
app.get('/api/devices/:ip', async (req, res) => {
    const device = devices.get(req.params.ip);
    if (!device) {
        return res.status(404).json({ error: 'Device not found' });
    }
    
    // Get current metrics
    const metrics = await getDeviceMetrics(req.params.ip);
    
    res.json({
        ...device,
        metrics
    });
});

// Ping device
app.post('/api/ping/:ip', async (req, res) => {
    try {
        const result = await ping.promise.probe(req.params.ip, {
            timeout: 2,
            extra: process.platform === 'win32' ? ['-n', '4'] : ['-c', '4']  // Windows vs Linux syntax
        });
        
        res.json({
            alive: result.alive,
            responseTime: result.time,
            packetLoss: result.packetLoss
        });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// ============================================
// WEBSOCKET SERVER
// ============================================

const wss = new WebSocket.Server({ port: 3001 });

wss.on('connection', (ws) => {
    console.log('WebSocket client connected');
    
    // Send current devices on connect
    try {
        const deviceList = Array.from(devices.values());
        ws.send(JSON.stringify({
            type: 'initial',
            data: deviceList,
            count: deviceList.length
        }));
    } catch (error) {
        console.error('Error sending initial data:', error);
    }
    
    ws.on('error', (error) => {
        console.error('WebSocket error:', error);
    });
    
    ws.on('close', () => {
        console.log('WebSocket client disconnected');
    });
});

function broadcastUpdate(type, data) {
    try {
        const message = JSON.stringify({ type, data, timestamp: new Date().toISOString() });
        console.log(`Broadcasting update: ${type} with ${Array.isArray(data) ? data.length : 'non-array'} items`);
        
        wss.clients.forEach(client => {
            if (client.readyState === WebSocket.OPEN) {
                try {
                    client.send(message);
                } catch (error) {
                    console.error('Error sending WebSocket message:', error);
                }
            }
        });
    } catch (error) {
        console.error('Error in broadcastUpdate:', error);
    }
}

// ============================================
// PERIODIC MONITORING
// ============================================

// Check device status every 30 seconds
setInterval(async () => {
    for (const [ip, device] of devices) {
        const isAlive = await ping.promise.probe(ip, { 
            timeout: 2,
            extra: process.platform === 'win32' ? ['-n', '1'] : ['-c', '1']
        });
        
        const oldStatus = device.status;
        device.status = isAlive.alive ? 'online' : 'offline';
        device.lastSeen = isAlive.alive ? new Date() : device.lastSeen;
        
        // Broadcast status change
        if (oldStatus !== device.status) {
            broadcastUpdate('status-change', {
                ip,
                status: device.status,
                lastSeen: device.lastSeen
            });
        }
    }
}, 30000);

// ============================================
// SERVER STARTUP
// ============================================

app.listen(PORT, () => {
    console.log(`
ââââââââââââââââââââââââââââââââââââââââââ
â     NETWORK MONITOR SERVER RUNNING     â
â âââââââââââââââââââââââââââââââââââââââââ£
â  Web Interface: http://localhost:${PORT}  â
â  WebSocket:     ws://localhost:3001   â
ââââââââââââââââââââââââââââââââââââââââââ

Network Information:
${JSON.stringify(getLocalNetwork(), null, 2)}

Ready to scan your network!
    `);
});

// ============================================
// PACKAGE.JSON FILE
// ============================================
// Save this as: package.json
/*
{
  "name": "network-monitor-backend",
  "version": "1.0.0",
  "description": "Network monitoring backend server",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "ping": "^0.4.4",
    "node-arp": "^1.0.6",
    "ws": "^8.14.2"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  }
}
*/

// ============================================
// CLIENT-SIDE INTEGRATION CODE
// ============================================
// Add this to your HTML file's script section:
/*

// Connect to backend API
const API_URL = 'http://localhost:3000/api';
const WS_URL = 'ws://localhost:3001';

let ws;

// Initialize WebSocket connection
function initWebSocket() {
    ws = new WebSocket(WS_URL);
    
    ws.onopen = () => {
        console.log('Connected to server');
        showNotification('Connected', 'Connected to monitoring server');
    };
    
    ws.onmessage = (event) => {
        const message = JSON.parse(event.data);
        handleServerUpdate(message);
    };
    
    ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        showNotification('Connection Error', 'Lost connection to server');
    };
    
    ws.onclose = () => {
        console.log('Disconnected from server');
        // Attempt to reconnect after 5 seconds
        setTimeout(initWebSocket, 5000);
    };
}

// Handle updates from server
function handleServerUpdate(message) {
    switch(message.type) {
        case 'initial':
            devices = message.data;
            updateDashboard();
            break;
        case 'scan-complete':
            devices = message.data;
            updateDashboard();
            showNotification('Scan Complete', `Found ${message.data.length} devices`);
            break;
        case 'status-change':
            const device = devices.find(d => d.ip === message.data.ip);
            if (device) {
                device.status = message.data.status;
                device.lastSeen = message.data.lastSeen;
                updateDashboard();
            }
            break;
    }
}

// Modified scanNetwork function to use backend
async function scanNetwork() {
    if (scanInProgress) return;
    
    scanInProgress = true;
    document.getElementById('scanLoader').style.display = 'inline-block';
    document.getElementById('scanText').textContent = 'Scanning...';
    
    try {
        const response = await fetch(`${API_URL}/scan`, {
            method: 'POST'
        });
        
        const result = await response.json();
        
        if (result.success) {
            devices = result.devices;
            updateDashboard();
        }
    } catch (error) {
        console.error('Scan failed:', error);
        showNotification('Scan Failed', 'Could not complete network scan');
    } finally {
        scanInProgress = false;
        document.getElementById('scanLoader').style.display = 'none';
        document.getElementById('scanText').textContent = 'ð Scan Network';
    }
}

// Modified pingDevice function to use backend
async function pingDevice(deviceId) {
    const device = devices.find(d => d.id === deviceId);
    if (device) {
        try {
            const response = await fetch(`${API_URL}/ping/${device.ip}`, {
                method: 'POST'
            });
            
            const result = await response.json();
            
            if (result.alive) {
                showNotification('Ping Response', 
                    `${device.name} responded in ${result.responseTime}ms`);
            } else {
                showNotification('Ping Failed', 
                    `${device.name} did not respond`);
            }
        } catch (error) {
            console.error('Ping failed:', error);
        }
    }
}

// Initialize WebSocket on page load
initWebSocket();

*/
